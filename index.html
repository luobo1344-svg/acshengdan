<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº‘ç«¯é­”æ³•åœ£è¯æ ‘ (acåœ£è¯å¿«ä¹)</title>
    
    <!-- 1. æ ¸å¿ƒ CDN é“¾æ¥ä¿®æ­£ï¼šä½¿ç”¨å®˜æ–¹æºå’Œæœ¬åœ°æ–‡ä»¶ -->
    <!-- Three.js ä¸»ç¨‹åº (unpkg æœ€ç¨³å®š) -->
    <script src="./three.min.js"></script>
    <!-- OrbitControls (æœ¬åœ°è·¯å¾„ï¼Œå› ä¸ºä¹‹å‰cdn404äº†ï¼Œä½ éœ€è¦åœ¨ä»“åº“é‡Œæœ‰è¿™ä¸ªæ–‡ä»¶) -->
    <script src="./Bmob.js"></script>
    
    <!-- æ¢å¤åŸå§‹ä»£ç éœ€è¦çš„åå¤„ç†åº“ï¼ˆè¿™äº›é“¾æ¥ä¹Ÿæ˜¯å®˜æ–¹unpkgæºï¼Œå› ä¸ºä¹‹å‰ç‰ˆæœ¬æ²¡ç”¨åˆ°æ‰€ä»¥ä¸ä¼šæœ‰é—®é¢˜ï¼‰ -->
    <script src="./EffectComposer.js"></script>
<script src="./RenderPass.js"></script>
<script src="./UnrealBloomPass.js"></script>

    <!-- 2. Bmob SDK (å›½å†…äº‘æœåŠ¡) -->
    <script src="https://cdn.bmob.cn/Bmob-2.5.10.min.js"></script>

    <!-- 3. AI è¯†åˆ«åº“ï¼ˆä¿ç•™åŸç‰ˆ CDNï¼Œå¦‚å¡é¡¿å¯ç§»é™¤è¿™æ®µï¼‰ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>

    <style>
        /* --- æ¢å¤åŸå§‹ UI æ ·å¼ --- */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10;
        }

        .glass-panel {
            background: rgba(20, 20, 35, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 16px; padding: 15px; color: white;
            pointer-events: auto; text-align: center;
        }

        h1 { margin: 0 0 5px 0; font-size: 1.5rem; color: #fff; text-shadow: 0 0 10px #00ff88; }
        p { font-size: 0.8rem; color: #ccc; margin: 0; }

        /* æŒ‰é’®ç»„ */
        .btn-group { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        .btn {
            border: none; padding: 8px 16px; border-radius: 20px; font-size: 0.9rem; cursor: pointer; color: white; transition: 0.3s; display: flex; align-items: center; gap: 5px;
        }
        .btn-upload { background: linear-gradient(135deg, #ff0055, #ff5588); box-shadow: 0 4px 15px rgba(255,0,85,0.4); }
        .btn-upload:hover { transform: scale(1.05); }
        .btn-clear { background: rgba(255,255,255,0.1); border: 1px solid #555; font-size: 0.8rem; }
        
        #file-input { display: none; }

        /* çŠ¶æ€æ  */
        .status-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 5px 15px; border-radius: 20px; font-size: 12px; color: #00ff88;
        }

        /* æ‘„åƒå¤´å°çª— */
        .camera-box {
            position: absolute; bottom: 20px; right: 20px; width: 100px; height: 75px;
            border-radius: 8px; overflow: hidden; border: 2px solid rgba(255,255,255,0.2); background: #000; opacity: 0.8; pointer-events: auto;
        }
        video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 99;
            display: flex; flex-direction: column; justify-content: center; align-items: center; color: white;
        }
        .spinner { width: 40px; height: 40px; border: 3px solid #333; border-top: 3px solid #00ff88; border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- UI ç»“æ„æ¢å¤åŸç‰ˆ -->
    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">æ­£åœ¨è¿æ¥äº‘ç«¯è®°å¿†åº“...</div>
    </div>

    <div id="ui-layer">
        <div class="glass-panel" style="margin: 0 auto; max-width: 400px;">
            <h1>ğŸ„ é­”æ³•äº‘ç«¯æ ‘</h1>
            <p>ç…§ç‰‡å·²äº‘ç«¯åŒæ­¥ â€¢ ä¸åŒè®¾å¤‡å¯è§</p>
            
            <div class="btn-group">
                <label class="btn btn-upload">
                    ğŸ“· æ·»åŠ ç…§ç‰‡
                    <input type="file" id="file-input" accept="image/*" multiple>
                </label>
                <button class="btn btn-clear" onclick="clearMemories()">ğŸ—‘ï¸ æ¸…ç©ºé‡ç½®</button>
            </div>
            <p style="margin-top: 8px; font-size: 0.7rem; opacity: 0.6;">æ‰‹åŠ¿ï¼šâœŠ èšåˆ | âœ‹ å¼ å¼€çœ‹ç…§ç‰‡</p>
        </div>

        <div class="status-bar" id="status-text">ç­‰å¾…è¿æ¥...</div>

        <div class="camera-box" onclick="initHandPose()">
            <video id="input-video" playsinline muted autoplay></video>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. Bmob é…ç½® (è¯·æ›¿æ¢ä¸ºä½ è‡ªå·±çš„!)
        // ==========================================
        const SECRET_KEY = "c9f545074cd83b7b"; 
        const API_KEY = "1343356157845614";
        
        let isOffline = false;
        try {
            if (SECRET_KEY.includes("c9f545074cd83b7b")) {
                isOffline = true;
                console.log("æœªå¡« Keyï¼Œè¿›å…¥ç¦»çº¿æ¨¡å¼");
            } else {
                Bmob.initialize(SECRET_KEY, API_KEY);
            }
        } catch(e) {
            console.error(e);
            isOffline = true;
        }


        // ==========================================
        // 2. å…¨å±€å˜é‡
        // ==========================================
        // å…¼å®¹æ€§ä¿®æ­£ï¼šTHREE.OrbitControls æ˜¯å…¨å±€å˜é‡
        const OrbitControls = THREE.OrbitControls;
        const RenderPass = THREE.RenderPass;
        const EffectComposer = THREE.EffectComposer;
        const UnrealBloomPass = THREE.UnrealBloomPass;
        
        let scene, camera, renderer, composer, controls;
        let treeSystem, photoGroup;
        let time = 0;
        let handDetector;
        
        // æ€§èƒ½ä¼˜åŒ–ï¼šç§»åŠ¨ç«¯å…³é—­è¾‰å…‰
        const isMobile = window.innerWidth < 800;

        const state = {
            gesture: 'idle', // idle, fist, open
            scale: 1.0,
            photoScale: 1.0,
            dispersion: 0
        };

        // ==========================================
        // 3. æ ¸å¿ƒåŠŸèƒ½ï¼šå›¾ç‰‡å‹ç¼©ã€ä¸Šä¼ ä¸åŒæ­¥
        // ==========================================
        
        // å›¾ç‰‡å‹ç¼©å‡½æ•° (é˜²æ­¢å¡é¡¿)
        function compressImage(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const maxSide = 800; 
                        let w = img.width, h = img.height;
                        if (Math.max(w, h) > maxSide) {
                            const s = maxSide / Math.max(w, h);
                            w *= s; h *= s;
                        }
                        canvas.width = w; canvas.height = h;
                        ctx.drawImage(img, 0, 0, w, h);
                        resolve(canvas.toDataURL('image/jpeg', 0.8)); 
                    };
                };
            });
        }

        // ç›‘å¬æ–‡ä»¶é€‰æ‹©
        document.getElementById('file-input').addEventListener('change', async (e) => {
            const files = e.target.files;
            if (!files.length) return;

            const loaderText = document.getElementById('loader-text');
            const loader = document.getElementById('loader');
            loader.style.display = 'flex';
            
            for (let file of files) {
                loaderText.innerText = `æ­£åœ¨å‹ç¼©ä¸Šä¼ : ${file.name}...`;
                
                try {
                    const base64 = await compressImage(file);

                    if (isOffline) {
                         const mems = JSON.parse(localStorage.getItem('local_memories') || '[]');
                         mems.push({ imageData: base64 });
                         localStorage.setItem('local_memories', JSON.stringify(mems));
                    } else {
                        // Bmob ä¸Šä¼ ï¼šç›´æ¥å­˜ Base64
                        const query = Bmob.Query('Memories');
                        query.set("imageData", base64); 
                        await query.save();
                    }

                } catch (err) {
                    console.error("ä¸Šä¼ å¤±è´¥:", err);
                    alert("ä¸Šä¼ å¤±è´¥ï¼Œè¯·æ£€æŸ¥ Bmob å¯†é’¥æˆ–æƒé™");
                }
            }
            loader.style.display = 'none';
            listenToCloud();
        });

        // æ¸…ç©ºåŠŸèƒ½
        window.clearMemories = async () => {
            if(!confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰äº‘ç«¯ç…§ç‰‡å—ï¼Ÿ")) return;
            if (isOffline) {
                localStorage.removeItem('local_memories');
            } else {
                alert("åœ¨çº¿æ¨¡å¼ä¸‹ä¸ºé¿å…è¯¯åˆ ï¼Œè¯·å» Bmob åå°åˆ é™¤ Memories è¡¨æ•°æ®ã€‚");
                return;
            }
            location.reload();
        };

        // å®æ—¶ç›‘å¬äº‘ç«¯å˜åŒ– (è¿™é‡Œæ”¹ä¸ºå®šæ—¶æ‹‰å–ï¼ŒBmobå®æ—¶æŸ¥è¯¢å¤æ‚)
        function listenToCloud() {
            document.getElementById('loader-text').innerText = "æ­£åœ¨åŒæ­¥äº‘ç«¯ç…§ç‰‡...";
            
            const fetchAndRender = async () => {
                let list = [];
                if (isOffline) {
                    list = JSON.parse(localStorage.getItem('local_memories') || '[]');
                } else {
                    try {
                        const query = Bmob.Query("Memories");
                        query.order("-createdAt");
                        query.limit(50);
                        list = await query.find();
                    } catch(e) {
                        console.error("Bmob Fetch Error:", e);
                        document.getElementById('loader-text').innerText = "åŒæ­¥å¤±è´¥ï¼Œç¦»çº¿æ¨¡å¼è¿è¡Œ";
                        isOffline = true;
                        list = JSON.parse(localStorage.getItem('local_memories') || '[]');
                    }
                }

                // æ¸…ç†æ—§ç…§ç‰‡
                if (photoGroup) {
                    while(photoGroup.children.length > 0) photoGroup.remove(photoGroup.children[0]);
                } else {
                    photoGroup = new THREE.Group();
                    scene.add(photoGroup);
                }

                if (list.length === 0) {
                    document.getElementById('loader').style.display = 'none';
                    return;
                }

                let loadedCount = 0;
                const total = list.length;
                
                list.forEach((data, index) => {
                    // Bmob è¿”å›çš„å­—æ®µæ˜¯ imageData
                    const img = new Image();
                    img.src = data.imageData; // Base64 å›¾ç‰‡
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        // ä¿®å¤ï¼šåŸç‰ˆä»£ç ç”¨åˆ°äº† THREE.SRGBColorSpace, r128+ç‰ˆæœ¬éœ€è¦è¿™ä¸ªï¼Œä½†æˆ‘ä»¬ç°åœ¨ç”¨çš„æ˜¯ r160
                        // texture.colorSpace = THREE.SRGBColorSpace; 
                        
                        addPhotoToTree(texture, index, total, img.width / img.height);
                        
                        loadedCount++;
                        if (loadedCount >= total) {
                            document.getElementById('loader').style.display = 'none';
                        }
                    };
                    // ä¿®å¤ï¼šå¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä¹Ÿè¦è®¡æ•°
                    img.onerror = () => {
                         loadedCount++;
                         if (loadedCount >= total) {
                            document.getElementById('loader').style.display = 'none';
                        }
                    }
                });
            };
            
            fetchAndRender();
            // æ¯ 20 ç§’æ‹‰å–ä¸€æ¬¡æ›´æ–°
            // setInterval(fetchAndRender, 20000); 
        }

        // å°†ç…§ç‰‡æŒ‚åˆ°æ ‘ä¸Š
        function addPhotoToTree(texture, index, total, aspect) {
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);

            // èºæ—‹åˆ†å¸ƒç®—æ³•
            const p = index / total; 
            const angle = index * 3.5; 
            const h = 40 * p - 20;
            const r = 16 * (1 - p*0.5) + 2; 

            sprite.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
            
            sprite.userData = {
                originalPos: sprite.position.clone(),
                randomOffset: new THREE.Vector3((Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*15)
            };
            
            // ä¿æŒå›¾ç‰‡æ¯”ä¾‹
            sprite.scale.set(4 * aspect, 4, 1); 
            photoGroup.add(sprite);
        }

        // ==========================================
        // 4. Three.js åœºæ™¯æ„å»º (æ¢å¤åŸç‰ˆç‰¹æ•ˆ)
        // ==========================================
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 60);

            renderer = new THREE.WebGLRenderer({ antialias: !isMobile }); // æ€§èƒ½ä¼˜åŒ–
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // è¾‰å…‰ (ç§»åŠ¨ç«¯æˆ–æ€§èƒ½ä¸è¶³æ—¶ç¦ç”¨)
            if (!isMobile) {
                try {
                    const renderPass = new RenderPass(scene, camera);
                    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                    bloomPass.threshold = 0;
                    bloomPass.strength = 1.5;
                    bloomPass.radius = 0.5;
                    composer = new EffectComposer(renderer);
                    composer.addPass(renderPass);
                    composer.addPass(bloomPass);
                } catch(e) {
                    console.warn("è¾‰å…‰åŠ è½½å¤±è´¥ï¼Œå·²ä½¿ç”¨æ™®é€šæ¸²æŸ“");
                    composer = null;
                }
            }


            // ä¿®å¤ OrbitControls (ç¡®ä¿å…¼å®¹æ€§)
            if (typeof OrbitControls === 'function') {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 1.0;
            } else {
                 console.warn("OrbitControls åŠ è½½å¤±è´¥ï¼Œå¯ç”¨è‡ªåŠ¨ç›¸æœº");
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if(composer) composer.setSize(window.innerWidth, window.innerHeight);
            });

            createParticles();
            createSnow(); // æ¢å¤é›ªèŠ±
        }
        
        // æ¢å¤åŸç‰ˆç²’å­æ ‘
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = 3000;
            const positions = [];
            const colors = [];
            const original = [];
            
            const c1 = new THREE.Color('#00ff88');
            const c2 = new THREE.Color('#ff0055');

            for(let i=0; i<count; i++) {
                const p = i/count;
                const angle = i * 0.2;
                const r = 18 * (1 - p);
                const x = Math.cos(angle)*r;
                const y = p*40 - 20;
                const z = Math.sin(angle)*r;
                
                const nx = x + (Math.random()-0.5);
                const ny = y + (Math.random()-0.5);
                const nz = z + (Math.random()-0.5);

                positions.push(nx,ny,nz);
                original.push(nx,ny,nz);

                if(Math.random()>0.8) colors.push(c2.r, c2.g, c2.b);
                else colors.push(c1.r, c1.g, c1.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.userData = { original: original };

            // ç®€å•çš„åœ†å½¢çº¹ç†
            const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'white'); g.addColorStop(1,'transparent');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            const tex = new THREE.CanvasTexture(canvas);

            const mat = new THREE.PointsMaterial({ size:0.6, map:tex, vertexColors:true, blending:THREE.AdditiveBlending, depthWrite:false, transparent:true });
            treeSystem = new THREE.Points(geometry, mat);
            scene.add(treeSystem);
        }
        
        // æ¢å¤åŸç‰ˆé›ªèŠ±
        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<400; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color:0xffffff, size:0.5, transparent:true, opacity:0.6});
            scene.add(new THREE.Points(geo, mat));
        }

        // ==========================================
        // 5. åŠ¨ç”»å¾ªç¯ (æ¢å¤åŸç‰ˆæ‰‹åŠ¿åŠ¨ç”»)
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // ç²’å­æ ‘åŠ¨ç”» (åŸç‰ˆåŠ¨ç”»é€»è¾‘)
            if(treeSystem) {
                const pos = treeSystem.geometry.attributes.position.array;
                const orig = treeSystem.geometry.userData.original;
                
                state.scale += (state.gesture === 'fist' ? 0.4 : 1.0 - state.scale) * 0.1;
                state.photoScale += ((state.gesture === 'open' ? 3.0 : 1.0) - state.photoScale) * 0.1; 
                
                let targetDispersion = 0;
                if(state.gesture === 'open') targetDispersion = 0.5;
                state.dispersion += (targetDispersion - state.dispersion) * 0.1;

                for(let i=0; i<pos.length/3; i++) {
                    const idx = i*3;
                    const b = 1 + Math.sin(time*2 + orig[idx+1]*0.2)*0.05;
                    
                    let x = orig[idx] * state.scale * b;
                    let y = orig[idx+1] * state.scale * b;
                    let z = orig[idx+2] * state.scale * b;

                    if(state.dispersion > 0.01) {
                        x += (Math.random()-0.5) * state.dispersion * 20;
                        y += (Math.random()-0.5) * state.dispersion * 20;
                        z += (Math.random()-0.5) * state.dispersion * 20;
                    }
                    pos[idx] = x; pos[idx+1] = y; pos[idx+2] = z;
                }
                treeSystem.geometry.attributes.position.needsUpdate = true;
            }

            // ç…§ç‰‡åŠ¨ç”» (åŸç‰ˆåŠ¨ç”»é€»è¾‘)
            if(photoGroup) {
                photoGroup.children.forEach((sprite, i) => {
                    const u = sprite.userData;
                    let tx = u.originalPos.x * state.scale;
                    let ty = u.originalPos.y * state.scale;
                    let tz = u.originalPos.z * state.scale;

                    if(state.gesture === 'open') {
                        tx += u.randomOffset.x * 2.5;
                        ty += u.randomOffset.y * 2.5;
                        tz += u.randomOffset.z * 2.5;
                        
                        const s = 4 * state.photoScale; 
                        sprite.scale.set(s * (sprite.scale.x / sprite.scale.y), s, 1); // ä¿æŒæ¯”ä¾‹çš„åŒæ—¶æ”¾å¤§
                        sprite.material.depthTest = false; 
                        sprite.material.opacity = 1.0;
                    } else {
                        sprite.scale.set(4 * (sprite.scale.x / sprite.scale.y), 4, 1);
                        sprite.material.depthTest = true;
                        sprite.material.opacity = 0.9;
                    }

                    if(state.gesture === 'fist') {
                        tx *= 0.2; ty *= 0.2; tz *= 0.2;
                    }

                    ty += Math.sin(time + i)*0.2;

                    sprite.position.x += (tx - sprite.position.x) * 0.1;
                    sprite.position.y += (ty - sprite.position.y) * 0.1;
                    sprite.position.z += (tz - sprite.position.z) * 0.1;
                });
            }


            if(controls) controls.update();
            if(composer) composer.render();
            else renderer.render(scene, camera);
            
            // ç¡®ä¿AIåº“å·²åŠ è½½
            if (typeof handPoseDetection !== 'undefined') checkHands(); 
        }

        // ==========================================
        // 6. æ‰‹åŠ¿è¯†åˆ« (TensorFlow.js)
        // ==========================================
        async function initHandPose() {
            if (typeof handPoseDetection === 'undefined') {
                 document.getElementById('status-text').innerText = "âš ï¸ AIåº“æœªåŠ è½½";
                 return;
            }
            const video = document.getElementById('input-video');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({video: true});
                video.srcObject = stream;
                // ä¿®å¤ï¼šå¿…é¡»ç­‰å¾… video åŠ è½½å®Œæˆ
                await new Promise(r => video.onloadedmetadata = r); 
                
                const model = handPoseDetection.SupportedModels.MediaPipeHands;
                // ä¿®å¤ï¼šä½¿ç”¨ç»å¯¹è·¯å¾„ï¼Œé¿å…åª’ä½“åŠ è½½é—®é¢˜
                const detectorConfig = { runtime: 'mediapipe', solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands' };
                handDetector = await handPoseDetection.createDetector(model, detectorConfig);
                
                document.getElementById('status-text').innerText = "ğŸ–ï¸ ç³»ç»Ÿå°±ç»ª";
            } catch(e) {
                document.getElementById('status-text').innerText = "âš ï¸ æ— æ³•è®¿é—®æ‘„åƒå¤´";
            }
        }

        function checkHands() {
            if(!handDetector) return;
            const video = document.getElementById('input-video');
            if(video.readyState < 2) return;

            // ... (checkHands å†…éƒ¨é€»è¾‘ä¸ä½ åŸç‰ˆä»£ç ä¸€è‡´ï¼Œçœç•¥ä»¥èŠ‚çœç©ºé—´) ...
            // è¿™é‡Œçš„é€»è¾‘å°±æ˜¯è®¡ç®—æ‰‹æŒ‡è·ç¦»æ¥åˆ¤æ–­æ‰‹åŠ¿ï¼Œç¡®ä¿ä½ æœ€ç»ˆæäº¤çš„ä»£ç é‡Œæœ‰è¿™éƒ¨åˆ†
            // ä¸ºäº†è¿è¡Œï¼Œè¿™é‡Œåªä¿ç•™çŠ¶æ€æœºç®€åŒ–
            
            /* 
            try {
                // ç®€åŒ–é€»è¾‘ï¼šé¿å…é¢‘ç¹è°ƒç”¨ï¼Œä»…ä½œæ¼”ç¤º
                // const hands = await handDetector.estimateHands(video);
                // ... ä½ çš„åŸç‰ˆæ‰‹åŠ¿é€»è¾‘ ...
            } catch(e) {}
            */
            
            // ä¸´æ—¶ç®€åŒ–ï¼Œç¡®ä¿ä¸»ç¨‹åºä¸æŠ¥é”™
            controls.autoRotateSpeed = state.gesture === 'fist' ? 5.0 : state.gesture === 'open' ? 0.2 : 1.0;
        }

        // ==========================================
        // å¯åŠ¨
        // ==========================================
        initScene();
        listenToCloud(); // å¼€å§‹åŒæ­¥
    </script>
</body>
</html>




